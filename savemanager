local httpService = game:GetService("HttpService")

-- Types and Helpers
type Dropdown = {Value: any, Values: {i: any}, Multi: boolean, Displayer: (v) -> (n)?, SetValue: (any) -> ()}

local DisplayerParser = {
    Encode = function(Value)
        local Encoded = {}

        for Val: any, Bool: boolean in Value do
            table.insert(Encoded, Val)
        end

        return Encoded
    end,
}

local function TableEqual(Table, Reflect)
    for Index, Value in Table do 
        if Reflect[Index] ~= Value then return false end 
    end 

    return true
end  

local function SetDisplayerDropdownValue(Dropdown: Dropdown, Value)
    if Dropdown.Multi then
        local Values = {}
        
        for _, DataValue in Value do 
            for _, DropdownValue in Dropdown.Values do 
                if typeof(DropdownValue) ~= 'table' or not TableEqual(DataValue, DropdownValue) then continue end 
                
                Values[DropdownValue] = true
                break
            end
        end
        
        Dropdown:SetValue(Values)
    else
        for _, DropdownValue in Dropdown.Values do 
            if typeof(DropdownValue) ~= 'table' or not TableEqual(Value, DropdownValue) then continue end 
            
            Dropdown:SetValue(DropdownValue)
            break
        end	
    end
end

-- ===========================
-- MAIN SAVE MANAGER
-- ===========================
local SaveManager = {} do
    SaveManager.Folder = "FluentSettings"
    SaveManager.Ignore = {}
    SaveManager.Options, SaveManager.Library = {} :: { [string]: {Type: string, Value: any, SetValues: (self: any, NewValue: { [any]: any }) -> nil, SetValue: (self: any, NewValue: any, ...any) -> nil, SetValueRGB: (self: any, NewValue: Color3, Transparency: number?) -> nil} }, {}
    
    -- NEW: Variable to store the Remote URL
    SaveManager.RemoteUrl = ""

    SaveManager.Parser = {
        Toggle = {
            Save = function(idx, object) 
                return { type = "Toggle", idx = idx, value = object.Value, Timestamp = object.Instance.CreatedAt } 
            end,
            Load = function(idx, data)
                if SaveManager.Options[idx] then 
                    SaveManager.Options[idx]:SetValue(data.value)
                end
            end,
        },
        Slider = {
            Save = function(idx, object)
                return { type = "Slider", idx = idx, value = object.Value, Timestamp = object.Instance.CreatedAt }
            end,
            Load = function(idx, data)
                if SaveManager.Options[idx] then 
                    SaveManager.Options[idx]:SetValue(data.value)
                end
            end,
        },
        Dropdown = {
            Save = function(idx, object)
                local HasDisplayer = object.CustomDisplayer
                
                return { type = "Dropdown", idx = idx, value = (HasDisplayer and object.Multi and DisplayerParser.Encode(object.Value) or object.Value), mutli = object.Multi, Timestamp = object.Instance.CreatedAt, displayer = HasDisplayer}
            end,
            Load = function(idx, data)
                if data.value == nil then return end
                
                local DropdownElement = SaveManager.Options[idx]
                if not DropdownElement then return end
                
                local Value = data.value 
                if typeof(Value) ~= 'table' or (not data.displayer) then
                    DropdownElement:SetValue(Value)
                    return
                end
                
                SetDisplayerDropdownValue(DropdownElement, Value)
            end,
        },
        Colorpicker = {
            Save = function(idx, object)
                return { type = "Colorpicker", idx = idx, value = object.Value:ToHex(), transparency = object.Transparency, Timestamp = object.Instance.CreatedAt }
            end,
            Load = function(idx, data)
                if SaveManager.Options[idx] then 
                    SaveManager.Options[idx]:SetValueRGB(Color3.fromHex(data.value), data.transparency)
                end
            end,
        },
        Keybind = {
            Save = function(idx, object)
                return { type = "Keybind", idx = idx, mode = object.Mode, key = object.Value, Timestamp = object.Instance.CreatedAt }
            end,
            Load = function(idx, data)
                if SaveManager.Options[idx] then 
                    SaveManager.Options[idx]:SetValue(data.key, data.mode)
                end
            end,
        },
        Input = {
            Save = function(idx, object)
                return { type = "Input", idx = idx, text = object.Value, Timestamp = object.Instance.CreatedAt }
            end,
            Load = function(idx, data)
                if SaveManager.Options[idx] and type(data.text) == "string" then
                    SaveManager.Options[idx]:SetValue(data.text)
                end
            end,
        },
    }

    function SaveManager:SetIgnoreIndexes(list)
        for _, key in next, list do
            self.Ignore[key] = true
        end
    end

    function SaveManager:SetFolder(folder)
        self.Folder = folder
        self:BuildFolderTree()
    end

    -- NEW: Function to set the Remote URL
    function SaveManager:SetRemoteUrl(url)
        self.RemoteUrl = url
    end

    -- NEW: Function to Load settings from GitHub/URL
    function SaveManager:LoadRemoteConfig()
        if self.RemoteUrl == "" then
            return self.Library:Notify({
                Title = "Remote Config",
                Content = "Error",
                SubContent = "Please enter a Remote URL first.",
                Duration = 5
            })
        end

        -- 1. Fetch data from URL
        local success, result = pcall(function()
            return game:HttpGet(self.RemoteUrl)
        end)

        if not success then
            return self.Library:Notify({
                Title = "Remote Config",
                Content = "Connection Failed",
                SubContent = "Could not reach URL. Check internet or link.",
                Duration = 7
            })
        end

        -- 2. Decode JSON
        local decodedData
        success, decodedData = pcall(function()
            return httpService:JSONDecode(result)
        end)

        if not success or type(decodedData) ~= "table" then
            return self.Library:Notify({
                Title = "Remote Config",
                Content = "Data Error",
                SubContent = "Remote file is not valid JSON.",
                Duration = 7
            })
        end

        -- 3. Apply settings
        local count = 0
        for _, option in next, decodedData.objects do
            if self.Parser[option.type] then
                task.spawn(self.Library.SafeCallback, self.Library, self.Parser[option.type].Load, option.idx, option)
                count = count + 1
            end
        end

        return self.Library:Notify({
            Title = "Remote Config",
            Content = "Success",
            SubContent = string.format("Synced %d settings from remote.", count),
            Duration = 5
        })
    end

    function SaveManager:Save(name): (boolean, string?)
        if (not name) then
            return false, "No config file is selected"
        end

        local fullPath = `{self.Folder}/settings/{name}.json`

        local data = {
            objects = {}
        }

        for idx, option in next, SaveManager.Options do
            if not self.Parser[option.Type] then continue end
            if self.Ignore[idx] then continue end

            data.objects[#data.objects + 1] = self.Parser[option.Type].Save(idx, option)
        end

        table.sort(data.objects, function(v1: { Timestamp: number }, v2: { Timestamp: number })
            return v1.Timestamp < v2.Timestamp
        end)

        local success, encoded = pcall(httpService.JSONEncode, httpService, data)
        if not success then
            return false, "Failed to JSON-Encode data"
        end

        writefile(fullPath, encoded)
        return true
    end

    function SaveManager:Load(name): (boolean, string?)
        if (not name) then
            return false, "No config file is selected"
        end

        local file = `{self.Folder}/settings/{name}.json`
        if not isfile(file) then return false, "invalid file" end

        local success, decoded = pcall(httpService.JSONDecode, httpService, readfile(file))
        if not success then return false, "decode error" end

        for _, option in next, decoded.objects do
            if self.Parser[option.type] then
                task.spawn(self.Library.SafeCallback, self.Library, self.Parser[option.type].Load, option.idx, option)
            end
        end

        self.Library:SetTheme(self.Library.Theme)

        return true
    end

    function SaveManager:IgnoreThemeSettings()
        self:SetIgnoreIndexes({ 
            "InterfaceManager_InterfaceTheme", "InterfaceManager_AcrylicToggle", "InterfaceManager_TransparentToggle", "InterfaceManager_MenuKeybind"
        })
    end

    function SaveManager:BuildFolderTree()
        local paths = {
            self.Folder,
            `{self.Folder}/settings`
        }

        for i = 1, #paths do
            local str = paths[i]
            if not isfolder(str) then
                makefolder(str)
            end
        end
    end

    function SaveManager:RefreshConfigList()
        local list = listfiles(`{self.Folder}/settings`)

        local out = {}
        for i = 1, #list do
            local file = list[i]
            if file:sub(-5) == ".json" then
                local pos = file:find(".json", 1, true)
                local start = pos

                if typeof(pos) == "number" and typeof(start) == "number" then
                    local char = file:sub(pos, pos)
                    while char ~= "/" and char ~= "\\" and char ~= "" do
                        pos = pos - 1
                        char = file:sub(pos, pos)
                    end

                    if char == "/" or char == "\\" then
                        local name = file:sub(pos + 1, start - 1)
                        if name ~= "options" then
                            out[#out + 1] = name
                        end
                    end
                end
            end
        end

        return out
    end

    function SaveManager:SetLibrary(library)
        self.Library = library
        self.Options = library.Options
    end

    function SaveManager:LoadAutoloadConfig()
        if isfile(`{self.Folder}/settings/autoload.txt`) then
            local name = readfile(`{self.Folder}/settings/autoload.txt`)

            local success, err = self:Load(name)
            if not success then
                return self.Library:Notify({
                    Title = "Interface",
                    Content = "Config loader",
                    SubContent = `Failed to load autoload config: {err}`,
                    Duration = 7
                })
            end

            return self.Library:Notify({
                Title = "Interface",
                Content = "Config loader",
                SubContent = string.format("Auto loaded config %q", name),
                Duration = 7
            })
        end

        return nil
    end

    function SaveManager:BuildConfigSection(tab)
        assert(self.Library, "Must set SaveManager.Library")

        local section = tab:AddSection("Configuration")

        section:AddInput("SaveManager_ConfigName",    { Title = "Config name" })
        section:AddDropdown("SaveManager_ConfigList", { Title = "Config list", Values = self:RefreshConfigList(), AllowNull = true })

        section:AddButton({
            Title = "Create config",
            Callback = function()
                local name = SaveManager.Options.SaveManager_ConfigName.Value

                if name:gsub(" ", "") == "" then 
                    return self.Library:Notify({
                        Title = "Interface",
                        Content = "Config loader",
                        SubContent = "Invalid config name (empty)",
                        Duration = 7
                    })
                end

                local success, err = self:Save(name)
                if not success then
                    return self.Library:Notify({
                        Title = "Interface",
                        Content = "Config loader",
                        SubContent = "Failed to save config: " .. err,
                        Duration = 7
                    })
                end

                self.Library:Notify({
                    Title = "Interface",
                    Content = "Config loader",
                    SubContent = string.format("Created config %q", name),
                    Duration = 7
                })

                SaveManager.Options.SaveManager_ConfigList:SetValues(self:RefreshConfigList())
                SaveManager.Options.SaveManager_ConfigList:SetValue(nil)

                return nil
            end
        })

        section:AddButton({Title = "Load config", Callback = function()
            local name = SaveManager.Options.SaveManager_ConfigList.Value

            local success, err = self:Load(name)
            if not success then
                return self.Library:Notify({
                    Title = "Interface",
                    Content = "Config loader",
                    SubContent = "Failed to load config: " .. err,
                    Duration = 7
                })
            end

            return self.Library:Notify({
                Title = "Interface",
                Content = "Config loader",
                SubContent = string.format("Loaded config %q", name),
                Duration = 7
            })
        end})

        section:AddButton({Title = "Overwrite config", Callback = function()
            local name = SaveManager.Options.SaveManager_ConfigList.Value

            local success, err = self:Save(name)
            if not success then
                return self.Library:Notify({
                    Title = "Interface",
                    Content = "Config loader",
                    SubContent = "Failed to overwrite config: " .. err,
                    Duration = 7
                })
            end

            return self.Library:Notify({
                Title = "Interface",
                Content = "Config loader",
                SubContent = string.format("Overwrote config %q", name),
                Duration = 7
            })
        end})

        section:AddButton({Title = "Refresh list", Callback = function()
            SaveManager.Options.SaveManager_ConfigList:SetValues(self:RefreshConfigList())
            SaveManager.Options.SaveManager_ConfigList:SetValue(nil)
        end})

        section:AddButton({
            Title = "Delete All Configs",
            Callback = function()
                local configFolder = `{self.Folder}/settings`
                local list = listfiles(configFolder)
                local deletedCount = 0
                
                for _, filePath in ipairs(list) do
                    if filePath:sub(-5) == ".json" then
                        pcall(function() 
                            delfile(filePath)
                            deletedCount = deletedCount + 1
                        end)
                    end
                end
                
                if isfile(`{configFolder}/autoload.txt`) then
                    delfile(`{configFolder}/autoload.txt`)
                end
                
                SaveManager.Options.SaveManager_ConfigList:SetValues({})
                SaveManager.Options.SaveManager_ConfigList:SetValue(nil)
                
                if AutoloadButton then
                    AutoloadButton:SetDesc("Current autoload config: none")
                end
                
                self.Library:Notify({
                    Title = "Config Deletion",
                    Content = "All configurations deleted",
                    SubContent = string.format("%d configuration files removed", deletedCount),
                    Duration = 7
                })
            end
        })
        local AutoloadButton
        AutoloadButton = section:AddButton({Title = "Set as autoload", Description = "Current autoload config: none", Callback = function()
            local name = SaveManager.Options.SaveManager_ConfigList.Value
            writefile(`{self.Folder}/settings/autoload.txt`, name)
            AutoloadButton:SetDesc("Current autoload config: " .. name)
            self.Library:Notify({
                Title = "Interface",
                Content = "Config loader",
                SubContent = string.format("Set %q to auto load", name),
                Duration = 7
            })
        end})

        if isfile(`{self.Folder}/settings/autoload.txt`) then
            local name = readfile(`{self.Folder}/settings/autoload.txt`)
            AutoloadButton:SetDesc("Current autoload config: " .. name)
        end

        section:AddButton({
            Title = "Clear Autoload",
            Description = "",
            Callback = function()
                if isfile(`{self.Folder}/settings/autoload.txt`) then
                    delfile(`{self.Folder}/settings/autoload.txt`)
                    AutoloadButton:SetDesc("Current autoload config: none")
                    
                    self.Library:Notify({
                        Title = "Interface",
                        Content = "Config Autoload",
                        SubContent = "Cleared autoload configuration",
                        Duration = 7
                    })
                else
                    self.Library:Notify({
                        Title = "Interface",
                        Content = "Config Autoload",
                        SubContent = "No autoload configuration was set",
                        Duration = 7
                    })
                end
            end
        })
        SaveManager:SetIgnoreIndexes({ "SaveManager_ConfigList", "SaveManager_ConfigName" })

        -- ===========================
        -- NEW REMOTE CONFIG SECTION
        -- ===========================
        local RemoteSection = tab:AddSection("Remote Configuration")

        RemoteSection:AddInput("SaveManager_RemoteUrl", {
            Title = "Remote JSON URL",
            Default = self.RemoteUrl,
            Placeholder = "https://gist.githubusercontent.com/..."
        })

        RemoteSection:AddButton({
            Title = "Sync from Remote",
            Description = "Downloads settings from the URL and applies them.",
            Callback = function()
                local url = SaveManager.Options.SaveManager_RemoteUrl.Value
                self:SetRemoteUrl(url)
                self:LoadRemoteConfig()
            end
        })

        RemoteSection:AddButton({
            Title = "Export JSON (Copy)",
            Description = "Saves current config to a temp file and copies code to clipboard.",
            Callback = function()
                local success = self:Save("temp_export_for_remote")
                if success then
                    local path = `{self.Folder}/settings/temp_export_for_remote.json`
                    if isfile(path) then
                        local content = readfile(path)
                        setclipboard(content)
                        self.Library:Notify({
                            Title = "Remote Config",
                            Content = "Export Success",
                            SubContent = "JSON copied to clipboard! Paste it on GitHub.",
                            Duration = 7
                        })
                    end
                end
            end
        })
    end

    SaveManager:BuildFolderTree()
end

return SaveManager
